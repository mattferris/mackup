#!/usr/bin/perl
#
# mackbld /etc/mackup/sets.d/set.yml /etc/mackup/global.yml
#

use File::Path qw(remove_tree);
use YAML::Tiny;

my $cfg = { 'global' => {}, 'sets' => {} };

#
# load config from files
#

for (my $i=@ARGV-1; $i>=0; $i--) {

    my $file = $ARGV[$i];

    unless (-f $file) {
        error(1, "file doesn't exist: $file");
    }

    info("reading file $file");

    my $yaml = YAML::Tiny->read($file);
    my $tmpcfg = $yaml->[0];

    if ($tmpcfg->{'global'}) {
        info("$file: found global configuration");
        $cfg->{'global'} = $tmpcfg->{'global'};
    }

    if ($tmpcfg->{'sets'}) {
        foreach my $s (keys(%{$tmpcfg->{'sets'}})) {

            info("$file: found set $s");

            if ($cfg->{'sets'}->{$s}) {
                error(2, "set already exists for $s");
            }

            my $tmpset = $tmpcfg->{'sets'}->{$s};

            if (!$tmpset->{'targets'}) {
                error(2, "no targets defined for $s");
            }

            #
            # check all targets in set have a run command and sources
            #

            my $hasrun = 0;
            my $hassrc = 0;

            $hasrun = 1 if $tmpset->{'run'};
            $hassrc = 1 if $tmpset->{'sources'} && @{$tmpset->{'sources'}};

            foreach my $t (keys(%{$tmpset->{'targets'}})) {
                my $tmptgt = $tmpset->{'targets'}->{$t};

                unless ($hasrun || $tmptgt->{'run'}) {
                    error(2, "no run command defined for target $t in set $s");
                }

                unless ($hassrc || ($tmptgt->{'sources'} && @{$tmptgt->{'sources'}})) {
                    error(2, "no sources defined for target $t in set $s");
                }
            }

            $cfg->{'sets'}->{$s} = $tmpcfg->{'sets'}->{$s};

        }
    }

}

#
# check for required options
#

foreach my $key (@{['cachedir', 'datadir', 'logdir', 'libdir']}) {
    if (!$cfg->{'global'}->{$key} || $cfg->{'global'}->{$key} eq '') {
        error(2, "global option $key is undefined");
    }

    if (! -d $cfg->{'global'}->{$key}) {
        error(2, "$key path ".$cfg->{'global'}->{$key}." doesn't exist");
    }
}

#
# build the sets
#

foreach my $set (keys(%{$cfg->{'sets'}})) {
    buildset($set, $cfg->{'sets'}->{$set});
}

#
# error sub
#
sub error {
    my $code = shift;
    my $msg = shift;
    print STDERR "error: $msg\n";
    exit $code;
}

#
# info sub
#
sub info {
    my $msg = shift;
    print STDERR "info: $msg\n";
}

#
# buildset sub
#
sub buildset {
    local $name = shift;
    local $set = shift;

    info("proceeding to build set $name");

    local $cachedir = $cfg->{'global'}->{'cachedir'} .'/'. $name;
    local $datadir = $cfg->{'global'}->{'datadir'} .'/'. $name;
    local $logdir = $cfg->{'global'}->{'logdir'} .'/'. $name;

    # wipe cache if it exists
    if (-d $cachedir) {
        info("$name: wiping existing config cache");
        remove_tree($cachedir, { error => \my $err });
        if (@$err) {
            error(3, "$name: failed to wipe config cache");
        }
    }

    # build fresh cache
    info("$name: creating config cache");
    mkdir($cachedir) || error(3, "$name: failed to create config cache $cachedir");

    if (! -d $datadir) {
        info("$name: creating data directory");
        mkdir($datadir) || error(3, "$name: failed to create data directory $datadir");
    }

    if (! -d $logdir) {
        info("$name: creating log directory");
        mkdir($logdir) || error(3, "$name: failed to create log directory $logdir");
    }

    # build targets
    foreach my $t (keys(%{$set->{'targets'}})) {
        my $tgtdir = "$cachedir/$t";
        mkdir($tgtdir) || error(3, "$name: failed to create target directory $tgtdir");

        my $tgtcfg = $set->{'targets'}->{$t};

        if (!$tgtcfg->{'run'}) {
            $tgtcfg->{'run'} = $set->{'run'};
        }

        if (!$tgtcfg->{'sources'}) {
            $tgtcfg->{'sources'} = $set->{'sources'};
        }

        if ($set->{'options'}) {
            $tgtcfg->{'options'} = {} if !$tgtcfg->{'options'};
            foreach my $opt (keys(%{$set->{'options'}})) {
                if (!$tgtcfg->{'options'}->{$o}) {
                    $tgtcfg->{'options'}->{$opt} = $set->{'options'}->{$o};
                }
            }
        }

        buildtarget($tgtdir, $tgtcfg);

        my $tdatadir = "$datadir/$t";
        if (! -d $tdatadir) {
            mkdir($tdatadir) || error(3, "$name: failed to create target data directory $tdatadir");
            symlink($tgtdir, "$tdatadir/control") || error(3, "$name: failed to link config in target data directory contr -> $tgtdir");
        }
    }

    info("successfully built set $name");
}

#
# buildcfg
#
sub buildtarget {
    local $path = shift;
    local $tcfg = shift;

    if ($tcfg->{'run'}) {
        local $run = $tcfg->{'run'};
        if ($run !~ /^\//) {
            $run = $cfg->{'global'}->{'libdir'}.'/run/'.$run;
        }
        symlink($run, "$path/run") || error(3, "$name: failed to create symlink run -> $run");
    }

    if ($tcfg->{'sources'}) {
        open(SRC, ">$path/sources");
        foreach my $src (@{$tcfg->{'sources'}}) {
            print SRC "$src\n";
        } 
        close(SRC);
    }

    if ($tcfg->{'options'}) {
        mkdir("$path/env") || error(3, "$name: failed to create environment directory $path/env");
        foreach my $opt (keys(%{$tcfg->{'options'}})) {
            open(OPT, ">$path/env/".uc($opt));
            print OPT "$tcfg->{'options'}->{$opt}\n";
            close(OPT);
        }
    }
}
